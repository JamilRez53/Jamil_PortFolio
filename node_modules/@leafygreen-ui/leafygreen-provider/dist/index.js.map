{"version":3,"file":"index.js","sources":["../src/DarkModeContext.tsx","../src/MigrationContext/MigrationContext.tsx","../src/PortalContext.tsx","../src/TypographyContext.tsx","../src/UsingKeyboardContext.tsx","../src/LeafyGreenContext.tsx","../src/PopoverContext/PopoverContext.tsx","../src/PopoverPropsContext/PopoverPropsContext.tsx","../src/PopoverPropsContext/PopoverPropsContext.types.ts"],"sourcesContent":["import React, { createContext, PropsWithChildren, useContext } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { getTheme, Theme } from '@leafygreen-ui/lib';\n\ninterface DarkModeContextProps {\n  contextDarkMode?: boolean;\n  setDarkMode: React.Dispatch<boolean>;\n}\n\nconst DarkModeContext = createContext<DarkModeContextProps>({\n  contextDarkMode: false,\n  setDarkMode: () => {},\n});\nexport const useDarkModeContext = () => useContext(DarkModeContext);\n\ntype useDarkMode = (localDarkMode?: boolean) => {\n  darkMode: boolean;\n  theme: Theme;\n  setDarkMode: React.Dispatch<boolean>;\n};\n\nexport const useDarkMode: useDarkMode = localDarkMode => {\n  const { contextDarkMode, setDarkMode } = useDarkModeContext();\n  const darkMode = localDarkMode ?? contextDarkMode ?? false;\n  const theme = getTheme(darkMode);\n  return { darkMode, theme, setDarkMode };\n};\n\nfunction DarkModeProvider({\n  children,\n  contextDarkMode,\n  setDarkMode,\n}: PropsWithChildren<DarkModeContextProps>) {\n  return (\n    <DarkModeContext.Provider\n      value={{\n        contextDarkMode,\n        setDarkMode,\n      }}\n    >\n      {children}\n    </DarkModeContext.Provider>\n  );\n}\n\nDarkModeProvider.displayName = 'DarkModeProvider';\n\nDarkModeProvider.propTypes = {\n  children: PropTypes.node,\n  contextDarkMode: PropTypes.bool,\n};\n\nexport default DarkModeProvider;\n","import React, { createContext, PropsWithChildren, useContext } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { MigrationContextType } from './MigrationContext.types';\n\nexport const MigrationContext = createContext<MigrationContextType>({\n  forceUseTopLayer: false,\n});\n\n/**\n * Access the modal popover context\n */\nexport const useMigrationContext = (): MigrationContextType => {\n  return useContext(MigrationContext);\n};\n\n/**\n * Creates a global context for migration purposes.\n * Call `useMigrationContext` to access the migration context\n */\nexport const MigrationProvider = ({\n  children,\n  ...props\n}: PropsWithChildren<MigrationContextType>) => {\n  return (\n    <MigrationContext.Provider value={props}>\n      {children}\n    </MigrationContext.Provider>\n  );\n};\n\nMigrationProvider.displayName = 'MigrationProvider';\n\nMigrationProvider.propTypes = { children: PropTypes.node };\n","import React, { createContext, useContext } from 'react';\n\nexport interface PortalContextValues {\n  popover: {\n    portalContainer?: HTMLElement | null;\n    scrollContainer?: HTMLElement | null;\n  };\n}\n\nconst defaultPortalContextValues: PortalContextValues = {\n  popover: {\n    portalContainer: undefined,\n    scrollContainer: undefined,\n  },\n};\n\nconst PortalContext = createContext<PortalContextValues>(\n  defaultPortalContextValues,\n);\n\nexport function usePopoverPortalContainer() {\n  const { popover } = useContext(PortalContext);\n\n  return popover;\n}\n\ninterface PortalContext {\n  popover?: PortalContextValues['popover'];\n  children: React.ReactNode;\n}\n\nexport function PortalContextProvider({\n  popover = defaultPortalContextValues.popover,\n  children,\n}: PortalContext) {\n  return (\n    <PortalContext.Provider value={{ popover }}>\n      {children}\n    </PortalContext.Provider>\n  );\n}\n","import React, { createContext, PropsWithChildren, useContext } from 'react';\nimport PropTypes from 'prop-types';\n\n// TODO: Refresh - update to 13 | 16\ntype FontSize = 14 | 16;\nexport interface TypographyProviderProps {\n  /**\n   * The base font size of all LeafyGreen components unless overridden.\n   */\n  baseFontSize?: FontSize;\n}\n\nconst BaseFontSizeContext = createContext<FontSize>(14);\n\nexport function useBaseFontSize() {\n  return useContext(BaseFontSizeContext);\n}\n\nfunction TypographyProvider({\n  children,\n  baseFontSize = 14,\n}: PropsWithChildren<TypographyProviderProps>) {\n  return (\n    <BaseFontSizeContext.Provider value={baseFontSize}>\n      {children}\n    </BaseFontSizeContext.Provider>\n  );\n}\n\nTypographyProvider.displayName = 'TypographyProvider';\n\nTypographyProvider.propTypes = {\n  children: PropTypes.node,\n  baseFontSize: PropTypes.number,\n};\n\nexport default TypographyProvider;\n","import React, { createContext, useContext, useMemo, useState } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { useEventListener } from '@leafygreen-ui/hooks';\n\ninterface UsingKeyboardState {\n  usingKeyboard: boolean;\n  setUsingKeyboard: React.Dispatch<React.SetStateAction<boolean>>;\n}\n\nconst initialState: UsingKeyboardState = {\n  usingKeyboard: true,\n  setUsingKeyboard: () => {},\n};\n\nexport const UsingKeyboardContext =\n  createContext<UsingKeyboardState>(initialState);\n\n// All keys here are used to manage focus through keyboard interaction.\nexport const NavigationKeyCodes: { readonly [k: string]: number } = {\n  tab: 9,\n  leftArrow: 37,\n  upArrow: 38,\n  rightArrow: 39,\n  downArrow: 40,\n} as const;\n\nexport function useUsingKeyboardContext(): UsingKeyboardState {\n  return useContext(UsingKeyboardContext);\n}\n\ninterface UsingKeyboardProviderProps {\n  children?: React.ReactNode;\n}\n\nfunction UsingKeyboardProvider({ children }: UsingKeyboardProviderProps) {\n  // Initialize `usingKeyboard` to true\n  // Defaulting to true allows autofocus to display a focus state.\n  const [usingKeyboard, setUsingKeyboard] = useState(\n    initialState.usingKeyboard,\n  );\n\n  // When the user uses the mouse, they're not using the keyboard\n  useEventListener('mousedown', () => setUsingKeyboard(false), {\n    enabled: usingKeyboard,\n  });\n\n  // When the user presses a navigation key, they are using the keyboard\n  useEventListener(\n    'keydown',\n    ({ keyCode }) => {\n      if (Object.values(NavigationKeyCodes).includes(keyCode)) {\n        setUsingKeyboard(true);\n      }\n    },\n    { enabled: !usingKeyboard },\n  );\n\n  const providerValue = useMemo(\n    () => ({\n      usingKeyboard,\n      setUsingKeyboard,\n    }),\n    [usingKeyboard],\n  );\n\n  return (\n    <UsingKeyboardContext.Provider value={providerValue}>\n      {children}\n    </UsingKeyboardContext.Provider>\n  );\n}\n\nUsingKeyboardProvider.displayName = 'UsingKeyboardProvider';\n\nUsingKeyboardProvider.propTypes = { children: PropTypes.node };\n\nexport default UsingKeyboardProvider;\n","import React, { PropsWithChildren, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\n\nimport DarkModeProvider, { useDarkModeContext } from './DarkModeContext';\nimport { LeafyGreenProviderProps } from './LeafyGreenContext.types';\nimport { MigrationProvider, useMigrationContext } from './MigrationContext';\nimport {\n  PortalContextProvider,\n  usePopoverPortalContainer,\n} from './PortalContext';\nimport TypographyProvider, { useBaseFontSize } from './TypographyContext';\nimport UsingKeyboardProvider from './UsingKeyboardContext';\n\nfunction LeafyGreenProvider({\n  children,\n  baseFontSize: fontSizeProp,\n  popoverPortalContainer: popoverPortalContainerProp,\n  darkMode: darkModeProp,\n  forceUseTopLayer: forceUseTopLayerProp = false,\n}: PropsWithChildren<LeafyGreenProviderProps>) {\n  /**\n   * If `darkMode` prop is provided, use that. Otherwise, use context value\n   */\n  const { contextDarkMode: inheritedDarkMode } = useDarkModeContext();\n  const [darkModeState, setDarkMode] = useState(\n    darkModeProp ?? inheritedDarkMode,\n  );\n\n  useEffect(() => {\n    setDarkMode(darkModeProp ?? inheritedDarkMode);\n  }, [darkModeProp, inheritedDarkMode]);\n\n  /**\n   * If `baseFontSize` prop is provided, use that. Otherwise, use context value\n   */\n  const inheritedFontSize = useBaseFontSize();\n  const baseFontSize = fontSizeProp ?? inheritedFontSize;\n\n  /**\n   * If `popoverPortalContainer` prop is provided, use that. Otherwise, use context value\n   */\n  const inheritedContainer = usePopoverPortalContainer();\n  const popoverPortalContainer =\n    popoverPortalContainerProp ?? inheritedContainer;\n\n  /**\n   * If `forceUseTopLayerProp` is true, it will globally apply to all children\n   */\n  const migrationContext = useMigrationContext();\n  const forceUseTopLayer =\n    forceUseTopLayerProp || migrationContext.forceUseTopLayer;\n\n  return (\n    <UsingKeyboardProvider>\n      <PortalContextProvider popover={popoverPortalContainer}>\n        <TypographyProvider baseFontSize={baseFontSize}>\n          <DarkModeProvider\n            contextDarkMode={darkModeState}\n            setDarkMode={setDarkMode}\n          >\n            <MigrationProvider forceUseTopLayer={forceUseTopLayer}>\n              {children}\n            </MigrationProvider>\n          </DarkModeProvider>\n        </TypographyProvider>\n      </PortalContextProvider>\n    </UsingKeyboardProvider>\n  );\n}\n\nLeafyGreenProvider.displayName = 'LeafyGreenProvider';\n\nLeafyGreenProvider.propTypes = {\n  popoverPortalContainer: PropTypes.shape({\n    popover: PropTypes.shape({\n      portalContainer: PropTypes.elementType,\n      scrollContainer: PropTypes.elementType,\n    }),\n  }),\n  baseFontSize: PropTypes.oneOf([14, 16]),\n  darkMode: PropTypes.bool,\n};\n\nexport default LeafyGreenProvider;\n","import React, {\n  createContext,\n  PropsWithChildren,\n  useContext,\n  useMemo,\n  useState,\n} from 'react';\nimport PropTypes from 'prop-types';\n\nimport { PopoverContextType } from './PopoverContext.types';\n\nexport const PopoverContext = createContext<PopoverContextType>({\n  isPopoverOpen: false,\n  setIsPopoverOpen: () => {},\n});\n\n/**\n * Access the popover context to read and write if a popover element is open in a modal\n */\nexport const usePopoverContext = (): PopoverContextType => {\n  return useContext(PopoverContext);\n};\n\n/**\n * Creates a Popover context to read and write if a popover element is open in a modal\n * Call `usePopoverContext` to access the popover state\n * This is defined separately from `PopoverPropsContext` to avoid incorrectly resetting `isPopoverOpen` value\n * We avoid renaming this provider because it will trigger major changes in all packages because\n * `@leafygreen-ui/leafygreen-provider` is a peer dependency to all LG packages\n */\nexport const PopoverProvider = ({ children }: PropsWithChildren<{}>) => {\n  const [isPopoverOpen, setIsPopoverOpen] = useState<boolean>(false);\n\n  const providerValue = useMemo(\n    () => ({\n      isPopoverOpen,\n      setIsPopoverOpen,\n    }),\n    [isPopoverOpen],\n  );\n\n  return (\n    <PopoverContext.Provider value={providerValue}>\n      {children}\n    </PopoverContext.Provider>\n  );\n};\n\nPopoverProvider.displayName = 'PopoverProvider';\n\nPopoverProvider.propTypes = { children: PropTypes.node };\n","import React, { createContext, PropsWithChildren, useContext } from 'react';\nimport PropTypes from 'prop-types';\n\nimport {\n  PortalContextProvider,\n  usePopoverPortalContainer,\n} from '../PortalContext';\n\nimport { PopoverPropsProviderProps } from './PopoverPropsContext.types';\n\nexport const PopoverPropsContext = createContext<PopoverPropsProviderProps>({});\n\n/**\n * Access the popover props context to read props passed to nested popover component instances\n */\nexport const usePopoverPropsContext = (): PopoverPropsProviderProps => {\n  return useContext(PopoverPropsContext);\n};\n\n/**\n * Creates a PopoverProps context to pass props to a deeply nested popover element\n * Call `usePopoverPropsContext` to access the popover state\n * This is defined separately from `PopoverContext` to avoid incorrectly resetting `isPopoverOpen` value\n */\nexport const PopoverPropsProvider = ({\n  children,\n  ...props\n}: PropsWithChildren<PopoverPropsProviderProps>) => {\n  const popoverPortalContext = usePopoverPortalContainer();\n  const popover = {\n    portalContainer:\n      props.portalContainer || popoverPortalContext.portalContainer,\n    scrollContainer:\n      props.scrollContainer || popoverPortalContext.scrollContainer,\n  };\n\n  return (\n    <PopoverPropsContext.Provider value={props}>\n      <PortalContextProvider popover={popover}>\n        {children}\n      </PortalContextProvider>\n    </PopoverPropsContext.Provider>\n  );\n};\n\nPopoverPropsProvider.displayName = 'PopoverPropsProvider';\n\nPopoverPropsProvider.propTypes = { children: PropTypes.node };\n","import { Transition } from 'react-transition-group';\n\n/**\n * These types are duplicated in `@leafygreen-ui/popover`: https://github.com/mongodb/leafygreen-ui/blob/02e1d77e5ed7d55f9b8402299eae0c6d540c53f8/packages/popover/src/Popover.types.ts\n *\n * We cannot import `PopoverProps` into `@leafygreen-ui/leafygreen-provider` without introducing a circular dependency.\n */\n\ntype TransitionProps = React.ComponentProps<typeof Transition<HTMLElement>>;\n\ntype TransitionLifecycleCallbacks = Pick<\n  TransitionProps,\n  'onEnter' | 'onEntering' | 'onEntered' | 'onExit' | 'onExiting' | 'onExited'\n>;\n\n/**\n * Options to render the popover element\n * @param Inline will render the popover element inline in the DOM where it's written\n * @param Portal will render the popover element in a new div appended to the body. Alternatively, can be portaled into a provided `portalContainer`\n * @param TopLayer will render the popover element in the top layer\n */\nexport const RenderMode = {\n  Inline: 'inline',\n  Portal: 'portal',\n  TopLayer: 'top-layer',\n} as const;\nexport type RenderMode = (typeof RenderMode)[keyof typeof RenderMode];\n\n/**\n * Options to control how the popover element is dismissed. This should not be altered\n * because it is intended to have parity with the web-native {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/popover popover attribute}\n * @param Auto will automatically handle dismissal on backdrop click or esc key press, ensuring only one popover is visible at a time\n * @param Manual will require that the consumer handle dismissal manually\n */\nconst DismissMode = {\n  Auto: 'auto',\n  Manual: 'manual',\n} as const;\ntype DismissMode = (typeof DismissMode)[keyof typeof DismissMode];\n\n/** Local implementation of web-native `ToggleEvent` until we use typescript v5 */\ninterface ToggleEvent extends Event {\n  type: 'toggle';\n  newState: 'open' | 'closed';\n  oldState: 'open' | 'closed';\n}\n\nexport interface RenderInlineProps {\n  /**\n   * Options to render the popover element\n   * @defaultValue 'top-layer'\n   * @param Inline will render the popover element inline in the DOM where it's written. This option is deprecated and will be removed in the future.\n   * @param Portal will render the popover element in a new div appended to the body. Alternatively, can be portaled into a provided `portalContainer`. This option is deprecated and will be removed in the future.\n   * @param TopLayer will render the popover element in the top layer\n   */\n  renderMode: 'inline';\n\n  /**\n   * When `renderMode=\"top-layer\"`, these options can control how a popover element is dismissed\n   * - `'auto'` will automatically handle dismissal on backdrop click or key press, ensuring only one popover is visible at a time\n   * - `'manual'` will require that the consumer handle dismissal manually\n   */\n  dismissMode?: never;\n\n  /**\n   * A callback function that is called when the visibility of a popover element rendered in the top layer is toggled\n   */\n  onToggle?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies a class name to apply to the portal element\n   * @deprecated\n   */\n  portalClassName?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies an element to portal within. If not provided, a div is generated at the end of the body\n   * @deprecated\n   */\n  portalContainer?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it passes a ref to forward to the portal element\n   * @deprecated\n   */\n  portalRef?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies the scrollable element to position relative to\n   * @deprecated\n   */\n  scrollContainer?: never;\n}\n\nexport interface RenderPortalProps {\n  /**\n   * Options to render the popover element\n   * @defaultValue 'top-layer'\n   * @param Inline will render the popover element inline in the DOM where it's written. This option is deprecated and will be removed in the future.\n   * @param Portal will render the popover element in a new div appended to the body. Alternatively, can be portaled into a provided `portalContainer`. This option is deprecated and will be removed in the future.\n   * @param TopLayer will render the popover element in the top layer\n   */\n  renderMode: 'portal';\n\n  /**\n   * When `renderMode=\"top-layer\"`, these options can control how a popover element is dismissed\n   * - `'auto'` will automatically handle dismissal on backdrop click or key press, ensuring only one popover is visible at a time\n   * - `'manual'` will require that the consumer handle dismissal manually\n   */\n  dismissMode?: never;\n\n  /**\n   * When `renderMode=\"top-layer\"`, this callback function is called when the visibility of a popover element is toggled\n   */\n  onToggle?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies a class name to apply to the portal element\n   * @deprecated\n   */\n  portalClassName?: string;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies an element to portal within. If not provided, a div is generated at the end of the body\n   * @deprecated\n   */\n  portalContainer?: HTMLElement | null;\n\n  /**\n   * When `renderMode=\"portal\"`, it passes a ref to forward to the portal element\n   * @deprecated\n   */\n  portalRef?: React.MutableRefObject<HTMLElement | null>;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies the scrollable element to position relative to\n   * @deprecated\n   */\n  scrollContainer?: HTMLElement | null;\n}\n\nexport interface RenderTopLayerProps {\n  /**\n   * Options to render the popover element\n   * @defaultValue 'top-layer'\n   * @param Inline will render the popover element inline in the DOM where it's written. This option is deprecated and will be removed in the future.\n   * @param Portal will render the popover element in a new div appended to the body. Alternatively, can be portaled into a provided `portalContainer`. This option is deprecated and will be removed in the future.\n   * @param TopLayer will render the popover element in the top layer\n   */\n  renderMode?: 'top-layer';\n\n  /**\n   * When `renderMode=\"top-layer\"`, these options can control how a popover element is dismissed\n   * - `'auto'` will automatically handle dismissal on backdrop click or key press, ensuring only one popover is visible at a time\n   * - `'manual'` will require that the consumer handle dismissal manually\n   */\n  dismissMode?: DismissMode;\n\n  /**\n   * A callback function that is called when the visibility of a popover element rendered in the top layer is toggled\n   */\n  onToggle?: (e: ToggleEvent) => void;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies a class name to apply to the portal element\n   * @deprecated\n   */\n  portalClassName?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies an element to portal within. If not provided, a div is generated at the end of the body\n   * @deprecated\n   */\n  portalContainer?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it passes a ref to forward to the portal element\n   * @deprecated\n   */\n  portalRef?: never;\n\n  /**\n   * When `renderMode=\"portal\"`, it specifies the scrollable element to position relative to\n   * @deprecated\n   */\n  scrollContainer?: never;\n}\n\ntype PopoverRenderModeProps =\n  | RenderPortalProps\n  | RenderInlineProps\n  | RenderTopLayerProps;\n\nexport type PopoverPropsProviderProps = {\n  /**\n   * Specifies the amount of spacing (in pixels) between the trigger element and the Popover content.\n   *\n   * default: `10`\n   */\n  spacing?: number;\n\n  /**\n   * Number that controls the z-index of the popover element directly.\n   */\n  popoverZIndex?: number;\n} & PopoverRenderModeProps &\n  TransitionLifecycleCallbacks;\n"],"names":["DarkModeContext","createContext","contextDarkMode","setDarkMode","useDarkModeContext","useContext","DarkModeProvider","_ref2","children","React","createElement","Provider","value","displayName","propTypes","PropTypes","default","node","bool","_excluded","MigrationContext","forceUseTopLayer","useMigrationContext","MigrationProvider","_ref","props","_objectWithoutProperties","defaultPortalContextValues","popover","portalContainer","undefined","scrollContainer","PortalContext","usePopoverPortalContainer","PortalContextProvider","_ref$popover","BaseFontSizeContext","useBaseFontSize","TypographyProvider","_ref$baseFontSize","baseFontSize","number","initialState","usingKeyboard","setUsingKeyboard","UsingKeyboardContext","NavigationKeyCodes","tab","leftArrow","upArrow","rightArrow","downArrow","UsingKeyboardProvider","_useState2","_slicedToArray","useState","useEventListener","enabled","keyCode","Object","values","includes","providerValue","useMemo","LeafyGreenProvider","fontSizeProp","popoverPortalContainerProp","popoverPortalContainer","darkModeProp","darkMode","_ref$forceUseTopLayer","forceUseTopLayerProp","inheritedDarkMode","darkModeState","useEffect","inheritedFontSize","inheritedContainer","migrationContext","shape","elementType","oneOf","PopoverContext","isPopoverOpen","setIsPopoverOpen","PopoverProvider","PopoverPropsContext","PopoverPropsProvider","popoverPortalContext","Inline","Portal","TopLayer","localDarkMode","_useDarkModeContext","theme","getTheme"],"mappings":"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"}